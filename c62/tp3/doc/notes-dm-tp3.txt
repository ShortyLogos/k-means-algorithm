ALGORITHME DU COURS : K-MEANS ALGORITHM

CONCEPT DE L'ALGORITHME :
	Chaque centro√Øde est un point de gravit√©.
	On doit v√©rifier la distance de chaque point dans le nuage de points
	par rapport √† chaque centro√Øde (on va utiliser numpy pour √ßa).
	
	Chacun des centro√Ødes se d√©place jusqu'√† temps que l'√©quilibre soit trouv√©
	(une prochaine it√©ration ne change rien au nombre de donn√©es dans chaque cluster).
	Pour mieux comprendre : visualiser qu'on tient un cabaret sur un doigt et que l'exercice se conclut
	lorsque le cabaret est parfaitement stabilits√©.
	
	Possible qu'on doit faire une autre matrice pour les centro√Ødes.
	Leurs valeurs vont √™tre des float (distance = valeur r√©elle, pas enti√®re). S'assurer que toutes les matrices soient des floats.
	Conserver l'information d'une mani√®re ou d'une autre sur le pr√©c√©dent centro√Øde de chaque mot afin de savoir si on continue de boucler ou pas.
	Si aucun changement pour l'ensemble des points dans le nuage de point, alors l'algorithme a termin√© son travail et on arr√™te l'ex√©cution.


Les squares vont √™tre notre ami
On va utiliser Pythagore pour calculer la distance entre les mots

Pour TP3:
-> ON EFFECTUE LES TESTS DONT ON A BESOIN ET ON STOCKE DANS BD. 
ON REMET LA BD POUR √âVITER LA N√âCESSIT√â DE R√âENTRAINER.
-> Lors de l'utilisation du TP3, ON NE R√âENTRAINE PAS, ON FAIT DE LA RECHERCHE √Ä PARTIR DE NOS DONN√âES.
-> On arrache la stoplist (on veut prendre en compte ces mots).


-------------------------------------
D√©roulement des op√©rations TP3 :
INIT :
	// PLACEMENT INITIAL DES CENTRO√èDES
	+ On choisit k mots au hasard pour obtenir leurs coordoonn√©es. On utilise ces coordoonn√©es pour placer les centro√Ødes √† l'initialisation.
	Attention, ces mots ne deviennt PAS les centro√Ødes.
	
BOUCLE :
	// D√©terminer le centro√Øde le plus pr√®s pour chaque point (mot) -> On va utiliser Pythagore/Least-squares pour cette √©tape
	// On calcule les nouvelles coordoonn√©es du centro√Øde en effectuant une moyenne des coordonn√©es de tous les points (mots) du cluster
		Formule : ùê∫=1/ùëõ(ùê¥_1+ùê¥_2+‚Ä¶+ùê¥_ùëõ)
	// On effectue une autre it√©ration tant qu'un point dans le syst√®me a chang√© de cluster

-------------------------------------

// POUR LE RAPPORT DE LAB :
+ Que peut-on d√©duire des clusters produits ? Se rattachent-ils √† des concepts g√©n√©raux ? Sont-ils tous significatifs, partiellement ou aucun d'entre eux ne l'est?
+ Appuyer nos remarques par les chiffres si possible
+ Qu'est-ce que le nombre de cluster change?
+ Qu'est-ce qui peut affecter la taille des clusters?

// POUR TP3 :
Notre main va juste avoir plus d'options via argparse
ex : main.py -c -t 5 -k 5 -n 10

-> Les performances de temps ne sont pas un crit√®re d'√©valuation pour TP3
-> METTRE LES TRACES POUR CHAQUE IT√âRATIONS (voir l'exemple res3textes_t5_k5_n10.txt

**IL SE PEUT QUE √áA PRENNE PLUSIEURS HEURES FAIRE UNE EX√âCUTION AVEC PLUSIEURS CLUSTERS
On output nos r√©sultats comme √ßa : main.py -c -t 5 -n 10 -k 2 > res_t5_k2_4textes.txt // on se fait une convention pour le nom de fichier



// ID√âE D'INNOVATION :
+ G√©n√©rer plusieurs BD √† partir de types de textes diff√©rents (Litt√©raire, Juridique, Scientifique)



// Exercice int√©ractif pour mieux visualiser le d√©roulement de l'algorithme :
https://www.naftaliharris.com/blog/visualizing-k-means-clustering/
Choisir "I'll Choose" et ensuite "Uniform"
